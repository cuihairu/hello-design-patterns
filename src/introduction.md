# 简介

设计模式通常可以归类为三大类：
- **创建型模式（Creational Patterns）**
- **结构型模式（Structural Patterns）**
- **行为型模式（Behavioral Patterns）**

这些类别帮助开发人员理解模式的目的和使用场景。以下是这些类别及其主要模式的简单说明：

### 创建型模式（Creational Patterns）

这些模式主要涉及对象的创建，旨在将对象的创建与使用分离。

#### 1. **单例模式（Singleton Pattern）**
   - **用途**：确保一个类只有一个实例，并提供一个全局访问点。
   - **示例**：数据库连接池。

#### 2. **工厂方法模式（Factory Method Pattern）**
   - **用途**：定义一个创建对象的接口，但让子类决定实例化哪个类。
   - **示例**：日志记录器，可以创建不同的日志记录方法。

#### 3. **抽象工厂模式（Abstract Factory Pattern）**
   - **用途**：提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。
   - **示例**：跨平台UI组件库。

#### 4. **建造者模式（Builder Pattern）**
   - **用途**：将复杂对象的构建过程分离，使同样的构建过程可以创建不同的表示。
   - **示例**：创建复杂的文档格式（如PDF、HTML）。

#### 5. **原型模式（Prototype Pattern）**
   - **用途**：使用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。
   - **示例**：剪贴板中的复制粘贴功能。

#### 6. **对象池模式（Object Pool Pattern）**
   - **用途**：
	- **数据库连接池**：在数据库驱动程序中使用对象池来管理数据库连接，可以减少频繁的连接创建和销毁，提高性能。
	- **线程池**：在多线程编程中，线程池用于管理和重用线程，避免频繁的线程创建和销毁，提高系统响应速度。
	- **对象缓存**：在内存中缓存频繁使用的对象，如字符串缓存、对象实例缓存等，减少对象的创建和销毁，提高性能。
	- **资源管理**：管理有限资源，如文件句柄、网络连接等，确保资源不被耗尽。
   - **示例**：数据库连接池。
   
   #### 7.  **服务定位器模式（Service Locator Pattern）**
 - **用途**: 旨在通过某种方式控制对象的创建，以实现更好的灵活性和复用性。
 - **示例**: 分布式系统的服务发现。

#### 8. **多例模式（Multiton Pattern）** 
- **用途**：确保某个类在每个给定的关键字上最多只有一个实例。 
- **示例**：数据库连接池，但不同的数据库实例。

### 结构型模式（Structural Patterns）

这些模式主要涉及对象或类的组合，旨在使用继承和组合来获得更大的结构。

#### 1. **适配器模式（Adapter Pattern）**
   - **用途**：将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以协同工作。
   - **示例**：电源适配器。

#### 2. **装饰模式（Decorator Pattern）**
   - **用途**：动态地给对象添加一些职责，而不改变其接口。
   - **示例**：为一个文本编辑器添加不同的功能（如加粗、斜体）。

##### 3. **代理模式（Proxy Pattern）**
   - **用途**：为其他对象提供一种代理以控制对这个对象的访问。
   - **示例**：远程代理（远程调用）、虚拟代理（懒加载）。

#### 4. **外观模式（Facade Pattern）**
   - **用途**：为子系统中的一组接口提供一个统一的高层接口，简化子系统的使用。
   - **示例**：简化复杂的API调用。

#### 5. **桥接模式（Bridge Pattern）**
   - **用途**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
   - **示例**：图形绘制系统中的形状和颜色分离。

#### 6. **组合模式（Composite Pattern）**
   - **用途**：将对象组合成树形结构以表示“部分-整体”的层次结构。
   - **示例**：文件系统中的文件和文件夹。

#### 7. **享元模式（Flyweight Pattern）**
   - **用途**：运用共享技术有效地支持大量细粒度对象。
   - **示例**：文本编辑器中字符的对象池。

#### 8. **依赖注入 (Dependency Injection)**
   - **用途**: 模式的主要用途是管理对象之间的依赖关系。
   - **示例**： Java Spring 框架。
   
#### 9. **双向桥接（Bidirectional Bridge）**
- **用途**: 要在于需要双向通信和交互的场景中，它提供了一种灵活且解耦的方式来实现这一目标。
- **示例**: 复杂UI框架,分布式系统,实时系统。


### 行为型模式（Behavioral Patterns）

这些模式主要涉及类和对象之间的职责分配，旨在使这些职责的分配更加明确。

#### 1. **策略模式（Strategy Pattern）**
   - **用途**：定义一系列算法，将每个算法封装起来，并使它们可以互换。
   - **示例**：排序算法的策略（如快排、归并排序）。

#### 2. **观察者模式（Observer Pattern）**
   - **用途**：定义对象间的一对多依赖关系，当一个对象的状态改变时，所有依赖于它的对象都会得到通知并自动更新。
   - **示例**：事件监听器。

#### 3. **命令模式（Command Pattern）**
   - **用途**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。
   - **示例**：GUI按钮的命令模式。

#### 4. **责任链模式（Chain of Responsibility Pattern）**
   - **用途**：为请求创建一个接收者对象的链，使多个对象都有机会处理请求，避免请求的发送者与接收者耦合。
   - **示例**：审批流程。

#### 5. **中介者模式（Mediator Pattern）**
   - **用途**：用一个中介对象来封装一系列对象之间的交互，使对象之间不需要直接相互引用。
   - **示例**：聊天室中的消息转发器。

#### 6. **迭代器模式（Iterator Pattern）**
   - **用途**：提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。
   - **示例**：集合框架中的迭代器。

#### 7. **模板方法模式（Template Method Pattern）**
   - **用途**：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。
   - **示例**：游戏开发中的主循环框架。

#### 8. **状态模式（State Pattern）**
   - **用途**：允许一个对象在其内部状态改变时改变它的行为，使对象看起来似乎修改了它的类。
   - **示例**：TCP连接状态机。

#### 9. **备忘录模式（Memento Pattern）**
   - **用途**：在不破坏封装性的前提下，捕获并外部化一个对象的内部状态，从而使对象能恢复到原先的状态。
   - **示例**：撤销功能。

#### 10. **解释器模式（Interpreter Pattern）**
- **用途**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
- **示例**：编译器或脚本解释器。

#### 11. **访问者模式（Visitor Pattern）**
- **用途**：表示一个作用于某对象结构中的各元素的操作，使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。
  - **示例**：对象结构中的元素处理，如编译器中的语法树遍历。

#### 12. **回调模式（Callback Pattern）**
-  **用途**： 处理异步操作和事件驱动的任务。
- **示例**:  Node.js 编程。

### 并发模式（Concurrency Patterns）

这些模式主要解决多线程环境中的问题，旨在协调多个线程或进程的协作。

#### 1. **生产者消费者模式（Producer-Consumer Pattern）**
- **用途**: 解决在多线程环境中协调生产者和消费者之间的关系。

#### 2. **工作窃取模式（Work Stealing Pattern）**

处理线程池中任务的动态负载均衡，线程在完成手头任务后可以从其他线程的任务队列中窃取任务。

#### 3. **读写锁模式（Read-Write Lock Pattern）**

允许多个线程同时读取一个共享资源，但只允许一个线程写入共享资源。

#### 4. **线程池模式（Thread Pool Pattern）**

通过提前创建一组线程来处理任务，减少了频繁创建和销毁线程的开销。

#### 5. **反应器模式（Reactor Pattern）**

通过将事件处理逻辑与事件分发机制分离，实现高性能的事件驱动处理。

#### 6. **主动器模式（Proactor Pattern）**

通过将事件处理逻辑与事件分发机制分离，实现高性能的事件驱动处理。

#### 7. **主动对象模式（Active Object Pattern）**：

通过将方法调用封装为任务对象并排队执行，避免了直接的同步调用。

#### 8. **Future 模式** 

用途：代表一个未来可能完成的异步任务的结果。 
示例：异步编程中的回调或 Promise。

#### 9. **信号量模式（Semaphore Pattern）** 

用途：控制对多个资源的访问，用于资源数有限的场景。 
示例：数据库连接池。

#### 10. **事件循环模式（Event Loop Pattern）** 
用途：用于处理和分发事件或消息，常见于异步编程模型。 
示例：Node.js 事件循环。

#### 11. **双重检查锁定模式（Double-checked Locking Pattern）** 
用途：减少锁的开销，确保在多线程环境下安全的初始化。 
示例：单例模式的线程安全实现。

### 特定领域模式（Domain-Specific Patterns）

这些模式专门用于特定的应用领域或技术领域。

#### 1. **MVC模式（Model-View-Controller Pattern）**

用于分离应用的内部表示、用户界面和控制逻辑。

#### 2. **MVVM模式（Model-View-ViewModel Pattern）**

主要用于WPF和Silverlight应用程序中，分离视图和业务逻辑。

#### 3. **对象-关系映射（ORM）模式** 

用途在面向对象编程与关系数据库系统之间创建一个映射，使对象可以映射到数据库表。
示例：Hibernate, Entity Framework。

#### 4. **事务脚本模式（Transaction Script Pattern）**

用于实现简单的业务逻辑，通过一系列命令和脚本处理事务。

#### 5. **事件溯源（Event Sourcing）**

通过记录对应用状态的所有更改事件来确保应用状态的可追溯性和一致性。


通过这些模式，开发人员可以更好地解决软件设计中的常见问题，提高代码的可维护性、可扩展性和可读性。