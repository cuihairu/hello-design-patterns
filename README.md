# hello-design-patterns

[在线查看](https://cuihairu.github.io/hello-design-patterns/)
## 设计模式

设计模式通常可以归类为三大类：**创建型模式（Creational Patterns）**、**结构型模式（Structural Patterns）** 和 **行为型模式（Behavioral Patterns）**。这些类别帮助开发人员理解模式的目的和使用场景。以下是这些类别及其主要模式的简单说明：

### 创建型模式（Creational Patterns）

这些模式主要涉及对象的创建，旨在将对象的创建与使用分离。

1. **单例模式（Singleton Pattern）**
   - **用途**：确保一个类只有一个实例，并提供一个全局访问点。
   - **示例**：数据库连接池。

2. **工厂方法模式（Factory Method Pattern）**
   - **用途**：定义一个创建对象的接口，但让子类决定实例化哪个类。
   - **示例**：日志记录器，可以创建不同的日志记录方法。

3. **抽象工厂模式（Abstract Factory Pattern）**
   - **用途**：提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。
   - **示例**：跨平台UI组件库。

4. **建造者模式（Builder Pattern）**
   - **用途**：将复杂对象的构建过程分离，使同样的构建过程可以创建不同的表示。
   - **示例**：创建复杂的文档格式（如PDF、HTML）。

5. **原型模式（Prototype Pattern）**
   - **用途**：使用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。
   - **示例**：剪贴板中的复制粘贴功能。

### 结构型模式（Structural Patterns）

这些模式主要涉及对象或类的组合，旨在使用继承和组合来获得更大的结构。

1. **适配器模式（Adapter Pattern）**
   - **用途**：将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以协同工作。
   - **示例**：电源适配器。

2. **装饰模式（Decorator Pattern）**
   - **用途**：动态地给对象添加一些职责，而不改变其接口。
   - **示例**：为一个文本编辑器添加不同的功能（如加粗、斜体）。

3. **代理模式（Proxy Pattern）**
   - **用途**：为其他对象提供一种代理以控制对这个对象的访问。
   - **示例**：远程代理（远程调用）、虚拟代理（懒加载）。

4. **外观模式（Facade Pattern）**
   - **用途**：为子系统中的一组接口提供一个统一的高层接口，简化子系统的使用。
   - **示例**：简化复杂的API调用。

5. **桥接模式（Bridge Pattern）**
   - **用途**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
   - **示例**：图形绘制系统中的形状和颜色分离。

6. **组合模式（Composite Pattern）**
   - **用途**：将对象组合成树形结构以表示“部分-整体”的层次结构。
   - **示例**：文件系统中的文件和文件夹。

7. **享元模式（Flyweight Pattern）**
   - **用途**：运用共享技术有效地支持大量细粒度对象。
   - **示例**：文本编辑器中字符的对象池。

### 行为型模式（Behavioral Patterns）

这些模式主要涉及类和对象之间的职责分配，旨在使这些职责的分配更加明确。

1. **策略模式（Strategy Pattern）**
   - **用途**：定义一系列算法，将每个算法封装起来，并使它们可以互换。
   - **示例**：排序算法的策略（如快排、归并排序）。

2. **观察者模式（Observer Pattern）**
   - **用途**：定义对象间的一对多依赖关系，当一个对象的状态改变时，所有依赖于它的对象都会得到通知并自动更新。
   - **示例**：事件监听器。

3. **命令模式（Command Pattern）**
   - **用途**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。
   - **示例**：GUI按钮的命令模式。

4. **责任链模式（Chain of Responsibility Pattern）**
   - **用途**：为请求创建一个接收者对象的链，使多个对象都有机会处理请求，避免请求的发送者与接收者耦合。
   - **示例**：审批流程。

5. **中介者模式（Mediator Pattern）**
   - **用途**：用一个中介对象来封装一系列对象之间的交互，使对象之间不需要直接相互引用。
   - **示例**：聊天室中的消息转发器。

6. **迭代器模式（Iterator Pattern）**
   - **用途**：提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。
   - **示例**：集合框架中的迭代器。

7. **模板方法模式（Template Method Pattern）**
   - **用途**：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。
   - **示例**：游戏开发中的主循环框架。

8. **状态模式（State Pattern）**
   - **用途**：允许一个对象在其内部状态改变时改变它的行为，使对象看起来似乎修改了它的类。
   - **示例**：TCP连接状态机。

9. **备忘录模式（Memento Pattern）**
   - **用途**：在不破坏封装性的前提下，捕获并外部化一个对象的内部状态，从而使对象能恢复到原先的状态。
   - **示例**：撤销功能。

10. **解释器模式（Interpreter Pattern）**
    - **用途**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    - **示例**：编译器或脚本解释器。

11. **访问者模式（Visitor Pattern）**
    - **用途**：表示一个作用于某对象结构中的各元素的操作，使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。
    - **示例**：对象结构中的元素处理，如编译器中的语法树遍历。

 12. **生产者消费者模式(Producer-Consumer Pattern）**
	 - **用途**：解决了在多线程环境中协调生产者和消费者之间的关系。
	 - **示例**:  需要在多个线程之间共享有限的资源。


通过这些模式，开发人员可以更好地解决软件设计中的常见问题，提高代码的可维护性、可扩展性和可读性。

## 开发

依赖[mdbook](https://github.com/rust-lang/mdBook)

